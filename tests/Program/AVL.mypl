// Source: https://www.programiz.com/dsa/avl-tree

struct Node {
  int key;
  Node left;
  Node right;
  int height;
}

function int height(Node N) {
  if (N == null){
    return 0;
  }

  return N.height;
}

function int max(int a, int b) {
  if(a > b) {
    return a;
  } else{
    return b;
  } 
}

// New node creation
function Node newNode(int key) {
  Node node = new Node(null, null, null, null);
  node.key = key;
  node.left = null;
  node.right = null;
  node.height = 1;

  return node;
}

// Rotate right
function Node rightRotate(Node y) {
  Node x = y.left;
  Node T2 = x.right;
  x.right = y;
  y.left = T2;
  y.height = max(height(y.left), height(y.right)) + 1;
  x.height = max(height(x.left), height(x.right)) + 1;
  return x;
}

// Rotate left
function Node leftRotate(Node x) {
  Node y = x.right;
  Node T2 = y.left;
  y.left = x;
  x.right = T2;
  x.height = max(height(x.left), height(x.right)) + 1;
  y.height = max(height(y.left), height(y.right)) + 1;
  return y;
}

// Get the balance factor of each node
function int getBalanceFactor(Node N) {
  if (N == null){
    return 0;
  }

  return (height(N.left) - height(N.right));
}

// Insert a node
function Node insertNode(Node node, int key) {
  // Find the correct postion and insert the node
  if (node == null){
    return (newNode(key));
  }
  
  if (key < node.key) {
    node.left = insertNode(node.left, key);
  }
  elseif (key > node.key){
    node.right = insertNode(node.right, key);
  }
  else {
    return node;
  }

  // Update the balance factor of each node and
  // balance the tree
  node.height = 1 + max(height(node.left), height(node.right));
  int balanceFactor = getBalanceFactor(node);

  if (balanceFactor > 1) {
    if (key < node.left.key) {
      return rightRotate(node);
    } elseif (key > node.left.key) {
      node.left = leftRotate(node.left);
      return rightRotate(node);
    }
  }
  if (balanceFactor < (0 - 1)) {
    if (key > node.right.key) {
      return leftRotate(node);
    } elseif (key < node.right.key) {
      node.right = rightRotate(node.right);
      return leftRotate(node);
    }
  }
  return node;
}

// Node with minimum value
function Node nodeWithMimumValue(Node node) {
  Node current = node;

  while (current.left != null) {
    current = current.left;
  }

  return current;
}

// Delete a node
function Node deleteNode(Node root, int key) {
  // Find the node and delete it
  if (root == null) {
    return root;
  }

  if (key < root.key){
    root.left = deleteNode(root.left, key);
  }
  elseif (key > root.key){
    root.right = deleteNode(root.right, key);
  }
  else {

    if ((root.left == null) or (root.right == null)) {
      Node temp = null;

      if (root.left == null) {
        temp = root.right;
      } else {
        temp = root.left;
      }

      if (temp == null) {
        temp = root;
        root = null;
      } else {
        root = temp;
      }

      delete temp;

    } else {
      Node temp = nodeWithMimumValue(root.right);
      root.key = temp.key;
      root.right = deleteNode(root.right, temp.key);
    }
  }

  if (root == null){
    return root;
  }

  // Update the balance factor of each node and
  // balance the tree
  root.height = 1 + max(height(root.left), height(root.right));

  int balanceFactor = getBalanceFactor(root);

  if (balanceFactor > 1) {
    if (getBalanceFactor(root.left) >= 0) {
      return rightRotate(root);
    } else {
      root.left = leftRotate(root.left);
      return rightRotate(root);
    }
  }
  if (balanceFactor < (0 - 1)) {
    if (getBalanceFactor(root.right) <= 0) {
      return leftRotate(root);
    } else {
      root.right = rightRotate(root.right);
      return leftRotate(root);
    }
  }
  return root;
}

// Print the tree
function void printTree(Node root, string indent, bool last) {
  if (root != null) {
    print(indent);
    // cout << indent;
    if (last) {
      print("R----");
      string tmpIndent = "   ";
      string_append(indent, tmpIndent);
      delete tmpIndent;
    } else {
      print("L----");
      string tmpIndent = "|  ";
      string_append(indent, tmpIndent);
      delete tmpIndent;
    }

    print(root.key);
    print("\n");
    printTree(root.left, indent, false);
    printTree(root.right, indent, true);

  }

  delete indent;
}


export function int main() {
  Node root = null;

  root = insertNode(root, 2);
  root = insertNode(root, 1);
  root = insertNode(root, 7);
  root = insertNode(root, 4);
  root = insertNode(root, 5);
  root = insertNode(root, 3);
  root = insertNode(root, 6);

  string indent = "";

  printTree(root, indent, false);
  
  delete indent;
  return 0;
}