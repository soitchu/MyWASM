struct String {
  array int value;
  int length;
  String next;
  bool pooled;
}

function String main_string_ini(String str) {
  return new String(string_to_array_int(str), length_string(str), null, true);
}

function String main_string_ini_unpooled(String str) {
  return new String(string_to_array_int(str), length_string(str), null, false);
}

function bool string_compare(String str1, String str2) {
  // array int str1Array = string_to_array_int(str1);
  // array int str2Array = string_to_array_int(str2);
  String currentString1 = str1;
  String currentString2 = str2;

  array int str1Array = str1.value;
  array int str2Array = str2.value;
  int str1Counter = 0;
  int str2Counter = 0;
  

  while((str1Array != null) and (str2Array != null)) {
    int value1 = str1Array[str1Counter];
    int value2 = str2Array[str2Counter];


    if(value1 != value2) {
      return false;
    }

    str1Counter = str1Counter + 1;
    str2Counter = str2Counter + 1;

    if(str1Counter >= length(str1Array)) {
      currentString1 = currentString1.next;

      if(currentString1 != null) {
        str1Array = currentString1.value;
        str1Counter = 0;
      } else {
        str1Array = null;
      }
    }

    if(str2Counter >= length(str2Array)) {
      currentString2 = currentString2.next;

      if(currentString2 != null) {
        str2Array = currentString2.value;
        str2Counter = 0;
      } else {
        str2Array = null;
      }
    }
  }

  if((currentString1 == null) and (currentString2 == null)) {
    return true;
  }

  return false;
}

function void string_append(String string_1, String string_2) {
  string_2 = main_string_copy(string_2);
  String current = string_1;
  String last_string = null;

  while(not (current == null)) {
    last_string = current;
    current = current.next;
  }

  last_string.next = string_2;
}

// Double check if deep copy is necessary
function String main_string_copy(String str) {
  if(str == null) {
    return null;
  }

  array int value = str.value;


  // If the string isn't pooled, then we need to 
  // copy the whole string
  if(not str.pooled) {
    int len = length(value);
    value = new int[len];

    for(int i = 0; i < len; i = i + 1) {
      value[i] = str.value[i];
    }
  }

  return new String(value, str.length, main_string_copy(str.next), str.pooled);
}

function int main_string_length(String str) {
  String current = str;
  int str_length = 0;

  while(not (current == null)) {
    str_length = str_length + current.length;
    current = current.next;
  }

  return str_length;
}

function void main_string_delete(String str) {
  String current = str;

  while(not (current == null)) {
    String temp = current.next;

    if(current.pooled == false) {
      delete current.value;
    }

    delete current;

    current = temp;
  }
}

function void string_print(String str) {
  String current = str;

  while(current != null) {
    print(current.value);
    current = current.next;
  }
}

function string itos(int a) {
  bool is_neg = a < 0;
  int size = 0;

  if(a < 0) {
    a = a * (0 - 1);
  }

  int val = a;

  while(val > 0) {
    size = size + 1;
    val = val / 10;
  }

  if(is_neg) {
    size = size + 1;
  }

  array int result = new int[size];

  if(is_neg) {
    result[0] = 45;
  }

  val = a;

  int index = 0;

  while(val > 0) {
    result[size - (index + 1)] = 48 + (val % 10);
    index = index + 1;
    val = val / 10;
  }

  return new String(result, size, null, false);
}


function void print_int(int a) {
  string str = itos(a);
  string_print(str);
  delete str;
} 

// TODO: This doesn't work with concatenated strings
function String get(String str, int index) {
  array int val = str.value;
  array int result = new int[1];
  int cummulative_length = str.length;
  int last_cummulative_length = 0;

  while((cummulative_length <= index) and (str.next != null)) {
    str = str.next;
    val = str.value;
    last_cummulative_length = cummulative_length;
    cummulative_length = cummulative_length + str.length;
  }


  if(cummulative_length <= index) {
    error("");
  }

  // h e l l -> o w o r l d
  // 0 1 2 3    0 1 2 3 4 5

  // 6
  

  result[0] = val[index - last_cummulative_length];

  
  return main_string_ini_unpooled(result);
}

function int stoi(String s) {
  String current = s;
  int val = 0;

  while(current != null) {
    array int int_string = string_to_array_int(current.value);

    int len = length(int_string);

    for(int i = 0; i < len; i = i + 1) {
      val = (val * 10) + (int_string[i] - 48);
    }

    current = current.next;
  }

  // delete s;
  return val;
} 

function string dtos(double d) {
  int precision = 10;
  int total_length = precision + 1;
  bool is_neg = (d < 0.0);

  if(is_neg) {
    // Since we need to add the negative sign
    total_length = total_length + 1;
    d = d * (0.0 - 1.0);
  }

  String int_part_string = itos(dtoi(d));
  array int int_part = int_part_string.value;
  int int_length = length(int_part);
  int offset = 0;


  total_length = total_length + int_length;

  double fract_part = d - itod(dtoi(d));
  array int result = new int[total_length]; 

  if(is_neg) {
    // Negative sign
    result[offset] = 45;
    offset = offset + 1;
  }

  // Copying the int_part
  for(int i = 0; i < int_length; i = i + 1) {
    result[offset] = int_part[i];
    offset = offset + 1;
  }
  
  // Decimal point
  result[offset] = 46;
  offset = offset + 1;
  
  // Getting the fractional part
  for (int j = 0; j < precision; j = j + 1) {
    fract_part = fract_part * 10.0;
    int digit = dtoi(fract_part);
    result[offset] = 48 + digit; 
    fract_part = fract_part - itod(digit);
    offset = offset + 1;
  }

  delete int_part_string;
  delete int_part;

  return new String(result, total_length, null, false);
}

function void print_double(double a) {
  string str = dtos(a);
  string_print(str);
  delete str;
} 

function double stod(String str) {
  array int int_arr = str.value;
  bool is_neg = false;
  bool found_decimal = false;
  double decimal_coeff = 10.0;
  double d = 0.0;


  for(int i = 0; i < length(int_arr); i = i + 1) {
    if(int_arr[i] == 45) {
      if(i != 0) {
        // error("");
      } else {
        is_neg = true;
      }
    }
     else {
      if((int_arr[i] >= 48) and (int_arr[i] <= 57)) {
        if(found_decimal) {
          d = d + (itod(int_arr[i] - 48) / decimal_coeff);
          decimal_coeff = decimal_coeff * 10.0;
        } else {
          d = (d * 10.0) + (itod(int_arr[i] - 48));
        }
      } 
      elseif(int_arr[i] == 46) {
        if(found_decimal) {
          error("");
        } else {
          found_decimal = true;
        }
      } 
      else {
        error("");
      }
    }
  }

  if(is_neg) {
    d = d * (0.0 - 1.0);
  }

  return d;
}

function void print_bool(bool boolean) {
  if(boolean) {
    string t = "true";
    string_print(t);
    delete t;
  } else {
    string f = "false";
    string_print(f);
    delete f;
  }
}

// function void allocate_struct(int size) {
//   int tmpOffset = allocate_memory(size + 4);
//   return tmpOffset - 4;
  

//   //   (local $tmpOffset i32)
//   //   local.get $size
//   //   i32.const 4
//   //   i32.add
//   //   call $allocate_memory
//   //   local.tee $tmpOffset
    
//   //   local.get $size
//   //   i32.store
    
//   //   local.get $tmpOffset
//   //   i32.const 4
//   //   i32.add
//   // )
// }
// function void print_bool_(bool a) {
//   if(a) {
//     array int value = new int[4];
//     value[0] = 116;
//     value[1] = 114;
//     value[2] = 117;
//     value[3] = 101;

//     string a = new String(value, 4, null, false);
//     print(a);
//     delete a;
//   } else {
//     array int value = new int[5];
//     value[0] = 102;
//     value[1] = 97;
//     value[2] = 108;
//     value[3] = 115;
//     value[4] = 101;

//     string a = new String(value, 5, null, false);
//     print(a);
//     delete a;
//   }
// } 


