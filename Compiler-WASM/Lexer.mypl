import "StringBuffer.mypl" as StringBuffer;

int column = 1;
int line  = 1;
string in_stream = null;
string lexeme = null;
string token_type = null;

function void read() {
    if(lexeme != null) {
        delete lexeme;
    }
    column = column + 1;
    lexeme = StringBuffer::read_char(); 
}

function void peek() {
    if(lexeme != null) {
        delete lexeme;
    }
    lexeme = StringBuffer::peek_char();
}

function bool isNumeric(string str) {
    // this can be optimized
    string char = get(str, 0);
    int charCode = stoi(char) + 48;
    delete char;
    delete str;
    return (charCode >= 48) and (charCode <= 57);
}

function bool isAlpha(string str) {
    // this can be optimized
    int charCode = stoi(str) + 48;
    return ((charCode >= 65) and (charCode <= 90)) or ((charCode >= 97) and (charCode <= 122));
}

function bool isSpace(string str) {
    int charCode = stoi(str) + 48;
    // Space = 32, tab = 9
    bool result = ((charCode == 32) or (charCode == 9) or isNewLine(str));

    return result;
}

function bool isNewLine(string str) {
    // this can be optimized
    int charCode = stoi(str) + 48;

    // CR = 13, LF = 10
    return ((charCode == 13) or (charCode == 10));
}

function bool is_valid_id(string str) {
    // this can be optimized
    int charCode = stoi(str) + 48;
    return isAlpha(str) or (charCode == 95) or isNumeric(str);
}

function void handle_whitespaces() {
    peek();
    while (isSpace(lexeme)) {
        // Since we know that the character is
        // a whitespace, we can eliminate it
        read();

        // If it's a new line, we must reset the 
        // column number and increment column number
        if (isNewLine(lexeme)) {
            column = 0;
            line = line + 1;
        }

        peek();
    }

    read();
}

function void handle_comments() {
    // if the next char is also /,
    // then it is actually a comment
    peek();
    // string nextCh = lexeme;
    string SLASH = "/";
    string SEMI = ";";
    string comment = "";


    // if (string_compare(SLASH, nextCh)) {
    //     lexeme = "";
    //     // // this.token_type = TokenType.COMMENT;

    //     // // remove the next / that's part of 
    //     // // the comment
    //     read();
    //     peek();

    //     // print("---");

    //     // // Since we don't support multiline comments
    //     // // we should stop when we read a newline or EOF
    //     // // TODO: add eof back
    //     // while ((lexeme != null) and (not string_compare(SEMI, lexeme)) and (not isNewLine(lexeme))) {
    //     //     print(lexeme);
    //     //     read();
    //     //     string_append(comment, lexeme);
    //     // }
    // }

    // print(comment);
    delete SLASH;
    delete SEMI;
    delete comment;
    delete lexeme;

}


export function int main() {
    for(int i = 0; i < 100; i = i + 1) {
        print("----");
    }
    // string code = "//    int a = 10;";
    // StringBuffer::ini(code);

    // handle_comments();

    // StringBuffer::close();
}